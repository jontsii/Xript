/*graphics drawing requires these things from the drivers:
    - a framebuffer
    - memory control APIs (free, allocate, copy)
*/
use gpu.GPULibMain;
use RamManager;
use Utils;

fn int getRGB(int r, int g, int b, int* dest) { //needs to be GPU accelerated for making pics faster
    int i = getThreadIndex();
    dest[i] = r * g * b;
}
class Texture {

    int[][] data;

    mt Texture init(int[] txtr, int width, int height) { //no GPU acceleration needed, estimatedly, this can make 29 000 Textures per second on i5 12400f (at max perfromance)
        int[][] temp = int[width][height]; 
        
        for (int i = 0, i < width, i += 1) {
            for (int j = 0, j < height, j += 1) {
                if (i == 0) int index = i + height + j;
                else int index = i * height + j;
                temp[i][j] = txtr[index];
            }
        }
        data = temp;
    }
}
class TextureData { //Frame class accepts this 
    Texture t;
    int[] data;
    float stretchAmount;

    mt TextureData init(Texture txtr, int x, int y) {
        t = txtr;
        data[0] = x;
        data[1] = y;
    }
}
class Frame {
    TextureData[] textures;
    int[] data;
    int backColor;
    string target;

    mt Frame init(TextureData[] txtrs, int height, int width, string targetWindow, int background) {
        textures = txtrs;
        data[0] = height;
        data[1] = width;
        target = targetWindow;
        backColor = background;
    }
}

static class FrameSerializer {
    mt int* serializeToFrameBuffer(Frame f) {
        
        int* framebuffer = GPUAlloc(sizeof(int) * f.data[0] * f.data[1]);
        
        gpu (ArrayUtils.getLength(f.textures)) {
            int i = getThreadIndex();
            TextureData txtr = f.textures[i];

            for (int j = 0, j < txtr.data[0] * txtr.data[1], j += f.width) { // j means the row itÂ´s going
                for (int k = txtr.data[0], k < f.width, k += 1) {
                    framebuffer[f.width * j + k] = txtr.t[k - txtr.data[0]];
                }
            }
        }
        return framebuffer;
    }
}