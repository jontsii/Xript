use Collections;
use GPU.Graphics.GraphicsObjects;
use Os;
use Events;
use Input;
use Utils;
unite layouts.xr;

struct Style {
    int[4] border;
    int[4] borderColor;
    int backColor;
    Texture backImage?;

    int foreColor;    
    Font f;
    int fontSize;

    int[4] margin;
    Event styleChanged = Event(callWindowSerializer, "this != this");
}
struct V2 {
    int x, y;
}

struct UIElementInfo {
    V2 pos;
    int width, height;
}

class UIElement {
    Window* motherWindow;

    V2 asolutePos;
    V2 pos;
    int width;
    int height;

    mt noll setPos(int x, int y) {
        pos.x = x;
        pos.y = y;
    }
    mt noll setSize(int width, int height) {
        this.width = width;
        this.height = height;
    } 
}

class Label ++ UIElement {
    priv string txt;
    Style style;

    mt Label init(string content, int size, Style s) {
        txt = content;
        style = s;
    }
    
    mt noll setText(string newTxt) {
        txt = newTxt;
        //TODO: make this call the window serializer so it can reserialize the window and pass it to the driver
    }
}

class Button ++ UIElement {
    Style style;
    string text;

    Event clicked;
    Event hover;
    Event mouseLeave;


    mt Button init(string txt, Style s) {
        style = s;
        text = txt;
        clicked = Event(noll, "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height && getMouseHit()"); //check if cursor is on button
        hover = Event(noll, "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height");
        mouseLeave = Event(noll, "!getMousePos()[0] <= x.x + x.width && !getMousePos()[0] >= x.x && !getMousePos()[1] >= x.y &&! getMousePos()[1] <= x.y + x.height");
    }

    mt noll disable() {
        clicked.cond = "false";
        hover.cond = "false";
        mouseLeave.cond = "false";
    }

    mt noll enable() {
        clicked.cond = "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height && getMouseHit()";
        hover.cond = "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height";
        mouseLeave.cond = "!getMousePos()[0] <= x.x + x.width && !getMousePos()[0] >= x.x && !getMousePos()[1] >= x.y && !getMousePos()[1] <= x.y + x.height";
    }
}

class TextBox ++ UIElement {
    Style style;
    priv string placeHolderText;
    priv int textLen;
    string text;
    GraphicText txt = GraphicText {Dictionary(int[], int), text};

    int caretPosition = 0;

    Event textChanged;
    priv Event txtChngd = Event(updateTextLen, "txtChngd", "StringUtils.getLen(text) != textLen");
    Event hover;
    Event mouseLeave;

    mt TextBox init(Style s) {
        style = s;
        textChanged.cond = "StringUtils.getLength(text) != textLen";
        hover.cond = "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height";
        mouseLeave.cond = "!getMousePos()[0] <= x.x + x.width && !getMousePos()[0] >= x.x && !getMousePos()[1] >= x.y && !getMousePos()[1] <= x.y + x.height";
    }

    priv mt noll updateTextLen() {
        wait 10;
        textLen = StringUtils.getLength(text);

        txt.text = text;
    }

    priv mt async noll updateTxtBox() {
        Key k;
        await while (true) {
            k = getKBHit();
            text += Enum.toString(k);
            caretPosition += 1;
        }
    }

    mt noll color(int color, int start, int end) {
        txt.coloredText.add(start, {end, color});
        //TODO: make this call the window serializer so it can reserialize the window and pass it to the driver
    }

    mt noll setPlaceHolderText(string txt) {
        placeHolderText = txt;
    }
}

class Canvas ++ UIElement {
    Style style;
    List coloredPixels = List(int[3]);
    
    float brushThickness;
    int brushColor;

    float transparency;

    Event isChanged;
    Event hover;
    Event mouseLeave;


    mt Canvas init(Style s) {
        style = s;

        isChanged.cond = "isMouseDown() && getMousePos() != getMousePos()";
        hover.cond = "getMousePos()[0] <= absolutePos.x + x.width && getMousePos()[0] >= absolutePos.x && getMousePos()[1] >= absolutePos.y && getMousePos()[1] <= absolutePos.y + x.height";
        mouseLeave.cond = "!getMousePos()[0] <= x.x + x.width && !getMousePos()[0] >= x.x && !getMousePos()[1] >= x.y && !getMousePos()[1] <= x.y + x.height";
        draw();
    }

    priv mt async noll draw() {
        int[] mousePos;
        await while (true) {
            mousePos = getMousePos();
            if (mousePos[0] < width + absolutePos.x && mousePos[0] > absolutePos.x &&
                mousePos[1] < height + absolutePos.y && mousePos[1] > absolutePos.y && getMouseDown()) {
                    coloredPixels.add({mousePos[0], mousePos[1], brushColor});
            }
        }
    }
}

class Image {
    Texture img;
    int height, width;
    
    V2 pos;    
    V2 absolutePos;


    mt Image init(int* pic) {
        img = Texture(pic);
    }
    
}

class Video {
    Image[] vid;
    int currentFrame;


    mt Video init(MP4 video) {
        //TODO: make a serializer in logical.xr to serialize pics, vids, etc.
    }
    
    mt noll play(int fps) {
        //TODO: call window serializer to reserialize window
    }
}

class Animation {
    priv Action[] windowSerializerInstr;

    mt Animation init(Action[] a) {
        windowSerializerInstr = a;
    }

    mt noll play(int speed) { //speed is fps
        for (Action a in windowSerializerInstr) {
            a.execute();
            wait 1 / speed;
        }
    }

    /*instructions are:
        MOVE objName, newPosition, speed (px / ms); move objName to newPosition at speed speed
        SET_COLOR objName, newColor, speed (RGB value / ms); set color of objName to newColor at speed speed
        ROTATE objName, orientation, speed (degree / ms); rotate objName to orientation at speed speed
        FADE objName, newPic, speed (px / ms), direction, color; fade object at speed
    */

    mt static Action[] serializeToAnimation(string[] instrs) {
        int i = 0;
        Action[] ans;

        string[] instrData;

        for (string instr in instrs) {
            instrData = StringUtils.split(instr, ',');
            if (instrData[0] == "MOVE") {
                //TODO: call window serializer to move it
            }
            else if (instrData[0] == "SET_COLOR") {
                //TODO: call window serializer to move it
            }
            else if (instrData[0] == "ROTATE") {
                //TODO: call window serializer to move it
            }
            else if (instrData[0] == "FADE") {
                //TODO: call window serializer to move it
            }
            else {
                //throw an exception
            }
        }
        return ans;
    }
}

class Slider ++ UIElement {
    Style style;
    int max;
    int min;
    priv int pixelPerValue;
    float value;
    priv float tempVal;
    int sliderPos;

    2DShape sliderShape;
    int sliderColor;

    Event valueChanged;

    mt Slider init(int maxAmount, int minAmount, Style s, 2DShape sliderShape, int sliderColor) {
        style = s;
        max = maxAmount;
        min = minAmount;
        
        pixelPerValue = width / maxAmount;
        valueChanged.cond = "tempVal != value";

        this.sliderShape = sliderShape;
        this.sliderColor = sliderColor;

        watchSliderValue();
    }

    

    priv mt async noll watchSliderValue() {
        int[] mousePos;
        await while (true) {
            if (isMouseDown()) {

                mousePos = getMousePos();
                if (mousePos[0] >= absolutePos.x + width) {
                    value = 100.0;
                    await wait 1
                    tempVal = value;
                    sliderPos = value;
                }

                else if (mousePos[0] <= absolutePos.x) {
                    value = 0.0;
                    await wait 1
                    tempVal = value;
                    sliderPos = value;
                }

                else {
                    value = (mousePos[0] - getWindow(motherWindow).x) / pixelPerValue;
                    await wait 1
                    tempVal = value;
                    sliderPos = value;
                }
            }
        }
    }
}

class CheckBox ++ UIElement {
    Style style;
    bool isChecked;
    string text;
    
    2DShape s = 2DShape.Square;
    Texture background;
    Texture unCheckedbackground;

    mt CheckBox init(Texture t, Texture ut, Style s, string txt) {
        background = t;
        unCheckedbackground = ut;
        this.s = s;
        style = s;
        text = txt;
    }

}

class RadioButton ++ UIElement {
    Style style;
    bool isChecked;
    
    string text;

    Texture background;
    Texture unCheckedbackground;

    mt RadioButton init(Texture t, Texture ut, Style s) {
        unCheckedbackground = ut;
        background = t;
        style = s;
    }
    
    priv mt async noll watchClicks() {
        int[] mousePos;
        await while (true) {
            mousePos = getMousePos();
            if (mousePos[0] < absolutePos.x + width && mousePos[0] > absolutePos.x &&
                mousePos[1] < absolutePos.y + height && mousePos[1] > absolutePos.y && getMouseClick == MouseButton.Left) {
                isChecked = true;    
            }
        }
    }
}

class RadioButtonGroup {
    List btns;
    RadioButton checked;

    mt RadioButtonGroup init(RadioButton[] buttons) {
        btns = List(RadioButton, buttons);
        updateChecked();
    }

    priv mt async noll updateChecked() {
        while (true) {
            for (RadioButton btn in btns) {
                if (btn.isChecked) {
                    checked = btn;
                    btns.remove(btn);
                    for (RadioButton _btn in btns) {
                        _btn.isChecked = false;
                    }
                    btns.add(btn);
                }
            }
        }
    }
}